diff --git a/signal_mailer/README.md b/signal_mailer/README.md
index b891cfc..09da6fe 100644
--- a/signal_mailer/README.md
+++ b/signal_mailer/README.md
@@ -46,28 +46,28 @@ python main.py
 
 (스케줄러 시작됨. Ctrl+C로 종료)
 
-## 동작 방식
+## 동작 방식 (QLD Core + Top-3 Ensemble)
 
 1. 매일 아침 설정된 시간에 자동 실행
-2. SPY의 20일 이동평균과 변동성 분석
-3. 위험신호 판단:
-   - 20일 MA < 25 percentile 또는
-   - 20일 변동성 > 75 percentile
-4. 신호 상태 변화가 있을 때만 메일 발송
-5. 모든 신호 이력은 signal_history.json에 저장
-6. 실행 로그는 mailer.log에 저장
-
-## 신호 해석
-
-[신호] NORMAL (QQQ 유지)
-- 정상 상태
-- 포지션 조정 불필요
-- SCHD 34% + QQQ 34% + XLP 0% + KOSPI 17% + GOLD 15%
-
-[신호] DANGER (QQQ->XLP 전환)
-- 위험신호 발생
-- QQQ를 XLP로 전환 권장
-- SCHD 34% + QQQ 0% + XLP 34% + KOSPI 17% + GOLD 15%
+2. QQQ의 110일 및 250일 단순 이동평균(SMA) 분석
+3. 위험신호 판단 (Hysteresis 적용):
+   - **NORMAL 진입**: QQQ 가격이 110일선과 250일선을 모두 상회할 때
+   - **DANGER 진입**: QQQ 가격이 110일선과 250일선을 모두 하회할 때
+   - **유지 (Stay)**: 그 외 구간(완충 지대)에서는 이전 상태를 유지하여 잦은 매매 방지
+4. 하락장 대응 (Top-3 Defensive Ensemble):
+   - 23종의 순수 1배물 방어 자산 중 8개월(168일) 상대 모멘텀 상위 3종 균등 배분
+   - 개별 자산의 모멘텀이 하락세( < 0)일 경우 해당 비중은 BIL(현금)로 대피
+5. 상태 변화 여부와 무관하게 매일 아침 데일리 리포트 발송
+6. 모든 신호 이력은 `signal_history.json`에 저장
+
+[신호] 🟢 NORMAL (CORE HOLDING)
+- 정상 상태: QQQ의 중장기 추세가 우호적임
+- 포트폴리오 비중: **QLD(45%)** + KOSPI(20%) + SPY(20%) + GOLD(15%)
+
+[신호] 🔴 DANGER (DEFENSIVE SWITCH)
+- 위험 상태: QQQ가 주요 이평선을 모두 하회하여 하락장 확정
+- 포트폴리오 비중: **최적 방어 자산 3종(각 15%)** + KOSPI(20%) + SPY(20%) + GOLD(15%)
+- 방어 자산 후보: 23종 슈퍼 앙상블 (BTAL, PFIX, DBMF, UUP, GLD, BIL 등)
 
 ## 다른 이메일 서비스 설정
 
diff --git a/signal_mailer/mailer.py b/signal_mailer/mailer.py
index cd3a0a7..d6c2ef9 100644
--- a/signal_mailer/mailer.py
+++ b/signal_mailer/mailer.py
@@ -90,7 +90,7 @@ class MailerService:
             message['To'] = recipient
             message['Subject'] = subject
             
-            message.attach(MIMEText(body, 'plain', 'utf-8'))
+            message.attach(MIMEText(body, 'html', 'utf-8'))
             
             # SMTP 발송
             smtp_server = email_config.get('smtp_server', 'smtp.gmail.com')
@@ -138,10 +138,9 @@ class MailerService:
         timestamp = datetime.now().isoformat()
         history[timestamp] = {
             'status': signal_status,
-            'is_danger': signal_info.get('is_danger', False),
-            'reason': signal_info.get('reason', ''),
-            'mf_score': float(signal_info.get('mf_score', 0)),
-            'm1_danger': bool(signal_info.get('m1_danger', False))
+            'is_danger': bool(signal_info.get('is_danger', False)),
+            'reason': str(signal_info.get('reason', '')),
+            'mf_score': float(signal_info.get('mf_score', 0))
         }
         
         try:
diff --git a/signal_mailer/main.py b/signal_mailer/main.py
index 91796d0..e61695e 100644
--- a/signal_mailer/main.py
+++ b/signal_mailer/main.py
@@ -3,8 +3,8 @@
 포트폴리오 신호 자동 감지 및 메일 발송 시스템
 
 매일 아침 설정된 시간에 자동으로 실행되어:
-1. SPY 기반 위험신호 감지
-2. 신호 발생 시 QQQ->XLP 전환 권장
+1. QQQ 기반 위험신호 감지 (Dual SMA 110/250)
+2. 신호 발생 시 QLD -> Top-3 Defensive Ensemble 전환 권장
 3. 상태 변화가 있을 때만 메일 발송
 4. 모든 신호 이력 기록
 
@@ -178,22 +178,39 @@ class SignalMailerSystem:
         self.check_and_send_signal()
     
     def test_email(self, recipient_email=None):
-        """이메일 발송 테스트"""
-        print("\n테스트 이메일 발송 중...\n")
+        """이메일 발송 테스트 (실제 신호 리포트 포함)"""
+        print("\n테스트 이메일 발송 중 (실시간 리포트 생성)...\n")
         
-        test_subject = "[포트폴리오] 테스트 메일"
-        test_body = f"""
-테스트 메일입니다.
-
-발송 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
-
-이메일 설정이 올바르게 완료되었습니다.
-
-포트폴리오 신호 메일러가 정상 작동 중입니다.
+        try:
+            # 1. 실시간 신호 감지
+            signal_info = self.detector.detect()
+            
+            # 2. 이전 상태 조회
+            previous_status = self.mailer.get_previous_status()
+            
+            # 3. 신호 리포트 생성
+            report = SignalDetector.format_signal_report(signal_info, previous_status)
+            
+            test_subject = f"[포트폴리오] 테스트 리포트: {report['status']}"
+            
+            # 4. 본문 구성 (HTML 형식을 위해 pre 태그 사용)
+            test_body = f"""
+<h2>포트폴리오 신호 메일러 테스트 실행</h2>
+<p>본 메일은 시스템 설정 확인을 위한 테스트 리포트입니다.</p>
+<hr>
+<pre style="font-family: 'Courier New', Courier, monospace; background-color: #f4f4f4; padding: 15px; border-radius: 5px; color: #333; line-height: 1.5;">
+{report['body']}
+</pre>
+<hr>
+<p style="color: #666; font-size: 0.9em;">발송 시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
 """
-        
-        result = self.mailer.send_email(test_subject, test_body, recipient_email)
-        print(f"결과: {result['message']}")
+            
+            result = self.mailer.send_email(test_subject, test_body, recipient_email)
+            print(f"결과: {result['message']}")
+            
+        except Exception as e:
+            print(f"테스트 이메일 발송 중 오류: {e}")
+            self.logger.error(f"테스트 이메일 발송 실패: {e}")
 
 
 def print_usage():
@@ -202,7 +219,7 @@ def print_usage():
 ╔════════════════════════════════════════════════════════════════════╗
 ║          포트폴리오 신호 자동 메일 발송 시스템                      ║
 ║                                                                    ║
-║  QQQ->XLP 전환 신호를 매일 아침 자동으로 감지하고 메일 발송        ║
+║  QLD -> Top-3 Ensemble 전환 신호를 매일 아침 자동으로 감지 및 발송 ║
 ╚════════════════════════════════════════════════════════════════════╝
 
 [ 1단계 ] config.yaml 설정
diff --git a/signal_mailer/signal_detector.py b/signal_mailer/signal_detector.py
index 93603bd..96e2697 100644
--- a/signal_mailer/signal_detector.py
+++ b/signal_mailer/signal_detector.py
@@ -11,49 +11,62 @@ class SignalDetector:
     """QQQ->XLP 전환 신호를 감지하는 클래스"""
     
     def __init__(self):
-        # yfinance 최신 버전은 자체적으로 curl_cffi 세션을 관리합니다
-        # 커스텀 세션을 전달하면 오류가 발생하므로 제거
         self.spy = yf.Ticker("SPY")
-        self.schd = yf.Ticker("SCHD")
         self.qqq_ticker = yf.Ticker("QQQ")
-        self.xlp_ticker = yf.Ticker("XLP")
         self.kospi200 = yf.Ticker("^KS200")
-        self.gld_ticker = yf.Ticker("GLD")
         self.vix_ticker = yf.Ticker("^VIX")
+        self.gld_ticker = yf.Ticker("GLD")
+        self.def_pool = [
+            "BTAL", "XLP", "XLU", "GLD", "FXY", "UUP", "MNA", "QAI", "DBC", "USFR", "GSY", 
+            "PFIX", "DBMF", "TAIL", "IVOL", "KMLM", "CTA", "PDBC", "SCHP", "TLT", "IEF", "BIL", "VXV",
+            "NTSX", "UBT", "UST"
+        ]
         
-    def fetch_data(self, days_back=450):
+    def fetch_data(self, days_back=500):
         """최근 데이터 및 지표용 선행 데이터 수집"""
         end_date = datetime.now()
         start_date = end_date - timedelta(days=days_back)
         
         try:
-            # yfinance history 사용 시 auto_adjust=False 설정 권장 (배당 미포함 종가 산출 위해)
-            spy_data = self.spy.history(start=start_date, end=end_date, auto_adjust=True)['Close']
-            qqq_data = self.qqq_ticker.history(start=start_date, end=end_date, auto_adjust=True)['Close']
-            kospi_data = self.kospi200.history(start=start_date, end=end_date, auto_adjust=False)['Close']
-            vix_data = self.vix_ticker.history(start=start_date, end=end_date, auto_adjust=False)['Close']
+            core_tickers = ["SPY", "QQQ", "^KS200", "^VIX", "GLD", "BIL"]
+            all_tickers = list(set(core_tickers + self.def_pool))
+            
+            # Group by ticker for more reliable extraction
+            raw_data = yf.download(all_tickers, start=start_date, end=end_date, progress=False, group_by='ticker')
+            
+            data_dict = {}
+            for ticker in all_tickers:
+                try:
+                    if ticker in raw_data.columns.get_level_values(0):
+                        t_data = raw_data[ticker]
+                        col = 'Adj Close' if 'Adj Close' in t_data.columns else 'Close'
+                        data_dict[ticker] = t_data[col]
+                except:
+                    pass
             
-            # 데이터가 비어있는지 확인
-            if spy_data.empty or qqq_data.empty or kospi_data.empty or vix_data.empty:
-                print("⚠️ 데이터가 비어있습니다. (YFinance 응답 오류 의심)")
-                return None, None, None, None
+            data = pd.DataFrame(data_dict)
+            
+            # QQQ가 필수인데 누락된 경우 개별 재시도
+            if 'QQQ' not in data.columns or data['QQQ'].dropna().empty:
+                qqq_fix = yf.download("QQQ", start=start_date, end=end_date, progress=False)
+                data['QQQ'] = qqq_fix['Adj Close'] if 'Adj Close' in qqq_fix.columns else qqq_fix['Close']
 
-            # 타임존 제거
-            for df in [spy_data, qqq_data, kospi_data, vix_data]:
-                if hasattr(df.index, 'tz') and df.index.tz is not None:
-                    df.index = df.index.tz_localize(None)
+            if data.empty:
+                print("⚠️ 데이터가 비어있습니다.")
+                return None
                 
-            return spy_data, qqq_data, kospi_data, vix_data
+            data = data.ffill()
+            return data
             
         except Exception as e:
             print(f"데이터 수집 오류: {e}")
-            return None, None, None
+            return None
     
-    def calculate_multifactor_score(self, spy_data, vix_data, lookback=126):
+    def calculate_multifactor_score(self, data, lookback=126):
         """사용자 제공 멀티팩터 CDF 스코어링 (0~100)"""
-        if spy_data is None or vix_data is None or len(spy_data) < lookback:
-            return 50.0 # 기본값
-            
+        spy_data = data['SPY']
+        vix_data = data['^VIX']
+        
         # 1. EMA 200 이격도
         ema200 = spy_data.ewm(span=200, adjust=False).mean()
         ema_dist = (spy_data - ema200) / ema200
@@ -64,7 +77,6 @@ class SignalDetector:
         loss = (-delta.where(delta < 0, 0)).rolling(14).mean()
         rsi = 100 - (100 / (1 + gain/loss.replace(0, np.nan))).fillna(100)
         
-        # 정규화 함수 (CDF)
         def get_score(series, inv=False):
             m = series.rolling(lookback).mean()
             s = series.rolling(lookback).std()
@@ -76,172 +88,120 @@ class SignalDetector:
         s_mom = get_score(rsi, inv=True)
         s_vol = get_score(vix_data, inv=False)
         
-        # 최종 점수 (3일 평균 가중치)
-        # 실제 운영에서는 최신 데이터의 CDF 점수를 가중 평균
-        score = (s_trend * 0.2 + s_mom * 0.4 + s_vol * 0.4)
-        return score
+        return (s_trend * 0.2 + s_mom * 0.4 + s_vol * 0.4)
 
-    def calculate_danger_signal(self, spy_data, qqq_data, vix_data):
+    def calculate_danger_signal(self, data, previous_status=None):
         """
-        [최적화 융합 모델] 위함신호 계산
-        - Sentinel (M1): 15d MA / 30d Vol (SPY 기반)
-        - Validator (M2): Multifactor CDF Score <= 40 (SPY/VIX 기반)
-        - Hard Floor: QQQ SMA 150 (설정값 기반)
+        [최적화 황금 조합] Dual SMA (110, 250) + Defensive Ensemble
         """
-        if spy_data is None or qqq_data is None or len(spy_data) < 126:
-            return {'is_danger': False, 'reason': '데이터 부족', 'date': datetime.now(), 'error': True}
-        
-        # 1. 기존 Sentinel 시그널 계산 (SPY 기반)
-        log_returns = np.log(spy_data.values[1:] / spy_data.values[:-1])
-        ma15_returns = pd.Series(log_returns).rolling(15).mean().values
-        std30_returns = pd.Series(log_returns).rolling(30).std().values
-        
-        ma_threshold = np.nanpercentile(ma15_returns, 25)
-        vol_threshold = np.nanpercentile(std30_returns, 65)
-        
-        latest_ma = ma15_returns[-1]
-        latest_vol = std30_returns[-1]
-        
-        m1_danger = (latest_ma < ma_threshold) or (latest_vol > vol_threshold)
+        if data is None or len(data) < 250:
+            return {'is_danger': False, 'reason': '데이터 부족', 'error': True}
+        
+        # 1. Dual SMA 110/250 Hysteresis Logic
+        curr_price = data['QQQ'].iloc[-1]
+        ma110 = data['QQQ'].rolling(110).mean().iloc[-1]
+        ma250 = data['QQQ'].rolling(250).mean().iloc[-1]
+        
+        if curr_price > ma110 and curr_price > ma250:
+            status = "NORMAL"
+        elif curr_price < ma110 and curr_price < ma250:
+            status = "DANGER"
+        else:
+            status = previous_status if previous_status else "NORMAL"
+            
+        is_danger = (status == "DANGER")
         
-        # 2. Multifactor Validator 점수 계산
-        mf_score = self.calculate_multifactor_score(spy_data, vix_data)
+        # 2. Defensive Asset Selection (Top-3 Momentum Ensemble)
+        # 8개월(168일) 수익률 기준 상위 3종 균등 배분 전략
+        mom_returns = data[self.def_pool].pct_change(168).iloc[-1].dropna().sort_values(ascending=False)
         
-        # 3. 전략 모드 및 설정 로드
-        import yaml
-        try:
-            with open('d:/gg/signal_mailer/config.yaml', 'r', encoding='utf-8') as f:
-                config = yaml.safe_load(f)
-                strategy_mode = config.get('strategy', {}).get('mode', 'hybrid')
-                ma_long = config.get('strategy', {}).get('ma_period_long', 150)
-                ma_short = config.get('strategy', {}).get('ma_period_short', 50)
-        except:
-            strategy_mode = 'hybrid'
-            ma_long = 150
-            ma_short = 50
-
-        is_danger = False
-        reason = ""
+        # Absolute Momentum Filter 적용 (모멘텀 > 0 인 것만)
+        valid_assets = mom_returns[mom_returns > 0].head(3)
         
-        # --- 전략별 로직 ---
+        if valid_assets.empty:
+            defensive_assets = ["BIL"]
+        else:
+            defensive_assets = valid_assets.index.tolist()
         
-        # A. Hybrid (Fusion + QQQ SMA Floor) - 추천/기본
-        if strategy_mode == 'hybrid':
-            # 1. Fusion 로직 (Sentinel & Validator 동시 만족)
-            fusion_danger = m1_danger and (mf_score <= 40)
-            
-            # 2. Hard Floor 체크 (QQQ 기준 SMA 하한선)
-            ma_floor = qqq_data.rolling(window=ma_long).mean().iloc[-1]
-            current_price = qqq_data.iloc[-1]
-            floor_breached = current_price < ma_floor
-            
-            if floor_breached:
-                is_danger = True
-                reason = f"DANGER (Hard Floor): QQQ 가격이 {ma_long}일 단순이평선 하회 ({current_price:.2f} < {ma_floor:.2f})"
-            elif fusion_danger:
-                is_danger = True
-                reason = f"DANGER (Fusion): 이중 확정 기술/심리 위기 (Score: {mf_score:.1f})"
-            else:
-                is_danger = False
-                reason = f"NORMAL: QQQ 이평선 지지중 & Fusion 안정 (Score: {mf_score:.1f})"
-
-        # B. Fusion (순수 기존 로직)
-        elif strategy_mode == 'fusion':
-            if m1_danger and mf_score <= 40:
-                is_danger = True
-                reason = f"이중 확정 위험: 기술지표 위기(Sentinel) & 심리지수 과열({mf_score:.1f}점)"
-            else:
-                is_danger = False
-                reason = f"정상 상태: Fusion 데이터 안정 (Score: {mf_score:.1f}점)"
-
-        # C. Faber (Meb Faber Style - Monthly)
-        elif strategy_mode == 'faber':
-            monthly_data = qqq_data.resample('M').last() # QQQ 기준으로 변경 가능
-            if len(monthly_data) < 12:
-                is_danger = False
-                reason = "데이터 부족 (Faber)"
-            else:
-                ma10mo = monthly_data.rolling(10).mean().iloc[-1]
-                current_month_close = monthly_data.iloc[-1]
-                if current_month_close < ma10mo:
-                    is_danger = True
-                    reason = f"DANGER (Faber): 월봉({current_month_close:.2f}) < 10개월 이평({ma10mo:.2f})"
-                else:
-                    is_danger = False
-                    reason = f"NORMAL (Faber): 월봉({current_month_close:.2f}) > 10개월 이평({ma10mo:.2f})"
-
-        # D. Golden Cross
-        elif strategy_mode == 'golden_cross':
-            ma_s = qqq_data.rolling(ma_short).mean().iloc[-1]
-            ma_l = qqq_data.rolling(ma_long).mean().iloc[-1]
-            if ma_s < ma_l:
-                is_danger = True
-                reason = f"DANGER (Death Cross): {ma_short}일({ma_s:.2f}) < {ma_long}일({ma_l:.2f})"
-            else:
-                is_danger = False
-                reason = f"NORMAL (Golden Cross): {ma_short}일({ma_s:.2f}) > {ma_long}일({ma_l:.2f})"
-        
-        # E. MA Only (Pure SMA 150)
-        elif strategy_mode == 'ma_only':
-            ma_val = qqq_data.rolling(window=ma_long).mean().iloc[-1]
-            current_price = qqq_data.iloc[-1]
-            if current_price < ma_val:
-                is_danger = True
-                reason = f"DANGER (SMA {ma_long}): QQQ가 {ma_long}일 이평선을 하회했습니다. ({current_price:.2f} < {ma_val:.2f})"
-            else:
-                is_danger = False
-                reason = f"NORMAL (SMA {ma_long}): QQQ가 {ma_long}일 이평선 위에 있습니다. ({current_price:.2f} > {ma_val:.2f})"
+        # 3. 추가 지표 (리포트용)
+        mf_score = self.calculate_multifactor_score(data)
+        rsi = (100 - (100 / (1 + (data['SPY'].diff().where(data['SPY'].diff() > 0, 0).rolling(14).mean() / 
+                                data['SPY'].diff().where(data['SPY'].diff() < 0, 0).abs().rolling(14).mean()).replace(0, np.nan))).fillna(100)).iloc[-1]
         
-        else:
-            is_danger = False
-            reason = f"NORMAL (Undefined Mode: {strategy_mode})"
-
         return {
             'is_danger': is_danger,
-            'reason': reason,
-            'date': datetime.now(),
+            'status_label': status,
+            'defensive_assets': defensive_assets,
+            'current_price': curr_price,
+            'ma110': ma110,
+            'ma250': ma250,
             'mf_score': mf_score,
-            'm1_danger': m1_danger,
-            'current_price': qqq_data.iloc[-1],
-            'ma_value': qqq_data.rolling(window=ma_long).mean().iloc[-1] if 'ma_long' in locals() else None,
-            'error': False,
-            'strategy': strategy_mode
+            'rsi': rsi,
+            'vix': data['^VIX'].iloc[-1],
+            'date': datetime.now(),
+            'error': False
         }
     
-    def detect(self):
+    def detect(self, previous_status=None):
         """신호 감지 실행"""
-        spy_data, qqq_data, kospi_data, vix_data = self.fetch_data()
-        return self.calculate_danger_signal(spy_data, qqq_data, vix_data)
+        data = self.fetch_data()
+        return self.calculate_danger_signal(data, previous_status)
     
     @staticmethod
     def format_signal_report(signal_info, previous_status=None):
-        """신호 리포트 포맷팅"""
-        is_danger = signal_info.get('is_danger', False)
-        error = signal_info.get('error', False)
-        
-        if error:
-            return {
-                'title': '신호 감지 오류',
-                'body': f"신호 감지 중 오류 발생:\n{signal_info.get('reason', 'Unknown error')}",
-                'status_changed': False,
-                'status': 'ERROR'
-            }
-        
-        # 신호 상태 판정
-        current_status = 'DANGER' if is_danger else 'NORMAL'
-        status_changed = (previous_status != current_status) if previous_status else False
-        timestamp = signal_info['date'].strftime("%Y-%m-%d %H:%M:%S")
-        
-        # SMA 150 정보 추가
-        ma_info = ""
-        if 'ma_value' in signal_info and signal_info['ma_value']:
-            ma_info = f"\nQQQ Current: {signal_info['current_price']:.2f}\nQQQ SMA 150: {signal_info['ma_value']:.2f}"
-            
-        body = f"Portfolio Signal Report\nTime: {timestamp}\nStatus: {current_status}\nReason: {signal_info['reason']}{ma_info}"
-        
+        """최적화 황금 조합 리포트 포맷팅"""
+        if signal_info.get('error'):
+            return {'title': 'ERROR', 'body': f"오류: {signal_info.get('reason')}", 'status': 'ERROR'}
+        
+        is_danger = signal_info['is_danger']
+        current_status = signal_info['status_label']
+        def_assets = signal_info['defensive_assets']
+        def_asset_str = ", ".join(def_assets)
+        emoji = "🔴" if is_danger else "🟢"
+        timestamp = signal_info['date'].strftime("%Y-%m-%d")
+        
+        # Action Label
+        action = f"DEFENSIVE SWITCH (to {def_asset_str})" if is_danger else "CORE HOLDING (QLD/KOSPI)"
+        
+        body = f"""
+============================================================
+📅 [{timestamp}] PORTFOLIO STRATEGY BRIEFING
+============================================================
+
+[1] MARKET STATUS: {emoji} {current_status} (Optimized Dual SMA)
+------------------------------------------------------------
+현재 전략     : {action}
+판단 근거     : QQQ 가격 vs Dual SMA (110, 250) 확정 신호
+QQQ 현재가    : ${signal_info['current_price']:.2f}
+SMA 110 (중기): ${signal_info['ma110']:.2f}
+SMA 250 (장기): ${signal_info['ma250']:.2f}
+
+[2] TOP-3 DEFENSIVE ENSEMBLE (최적 방패 3종)
+------------------------------------------------------------
+선정된 방어 자산: {def_asset_str} (각 15% 배분)
+- 8개월 상대 모멘텀 상위 3종 균등 분산
+- Absolute Momentum 필터(모멘텀 < 0일 시 현금 대피) 적용
+
+[3] ACTIONABLE ALLOCATION GUIDE
+------------------------------------------------------------
+| 전략자산 |    45.0%  | {"상기 방어 자산 매수" if is_danger else "QLD 유지"} |
+| KOSPI   |    20.0%  | 코어 분산 유지 |
+| SPY     |    20.0%  | 코어 포지션 유지 |
+| GOLD    |    15.0%  | 안전 자산 유지 |
+
+[4] TECHNICAL SNAPSHOT
+------------------------------------------------------------
+- Quant Score  : {signal_info['mf_score']:.1f} / 100
+- RSI(14)      : {signal_info['rsi']:.1f}
+- VIX(공포지수): {signal_info['vix']:.1f}
+
+------------------------------------------------------------
+Automated Daily Report | Golden Combo (110/250)
+============================================================
+"""
         return {
-            'title': current_status,
+            'title': f"{emoji} {current_status}",
             'body': body,
-            'status_changed': status_changed,
-            'status': current_status
+            'status': current_status,
+            'status_changed': (previous_status != current_status) if previous_status else False
         }
