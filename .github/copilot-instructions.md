# AI Copilot Instructions

## Project Overview
This is a quantitative portfolio management system with two main components:

1. **Crash Detection System** (`crash_detection_system/`) - Advanced market regime detection using Kalman Filter + Hidden Markov Model (HMM) for early crash signals
2. **Signal Mailer** (`signal_mailer/`) - Automated daily portfolio signal detection (QQQ↔XLP switching) with scheduled email notifications

The system runs on GitHub Actions (cloud automation) and supports local backtesting/analysis.

---

## Architecture & Data Flow

### Crash Detection Pipeline
```
Data Layer (yfinance: SPY, VIX, breadth indices)
    ↓
Noise Filtering (Kalman Filter: microstructure noise removal)
    ↓
Regime Detection (GaussianHMM: 3 states = Bull/Correction/Crisis)
    ↓
Signal Generation (Conditions A/B/C: momentum crashes + volatility spikes)
    ↓
Backtesting (vectorbt: Sharpe, Sortino, Max Drawdown metrics)
```

**Key Files:**
- `src/data_fetcher.py` - Downloads market data with caching for idempotency
- `src/signal_processor.py` - Implements Kalman Filter + HMM regime detection + ADX trend filtering
- `src/strategy.py` - Hybrid signal logic (SignalType enum: STRONG_BUY/SELL to NEUTRAL)
- `src/main.py` - Orchestrates pipeline and generates backtest reports (JSON + visualizations)

### Signal Mailer Pipeline
```
Config (YAML: email credentials, run time)
    ↓
Signal Detector (SPY MA20 + volatility percentiles for danger signals)
    ↓
MailerService (SMTP: Gmail/Naver/Outlook support)
    ↓
APScheduler (CronTrigger: daily 9 AM KST automation)
```

**Key Files:**
- `signal_mailer/main.py` - Entry point with BackgroundScheduler
- `signal_mailer/signal_detector.py` - Detects risk signals from SPY (20-day MA < 25th percentile OR volatility > 75th)
- `signal_mailer/mailer.py` - Sends formatted emails with state change tracking
- `config.yaml` - All credentials and timing (generator: `create_config.py`)

---

## Critical Conventions & Patterns

### 1. Idempotency & Fail-Safe Design
- **All scripts must be idempotent**: Safe to run multiple times without side effects
- **Caching mechanism** in `data_fetcher.py` prevents duplicate API calls
- **Checkpoint-Rollback pattern**: Long operations save progress; on failure, resume or rollback
- **Rationale**: Cloud automation (GitHub Actions) may retry; local scripts may be interrupted

### 2. Full Data Context (Never Summarize)
- Process entire datasets, not subsets: "Full Context" principle from PROJECT_RULES.md
- For missing data: use forward-fill then backward-fill (not dropping rows)
- Always validate timestamps and data continuity before analysis
- This is a quant finance project; precision matters more than speed

### 3. Structured Logging & Auditing
- Every module has `logger = logging.getLogger(__name__)` at top
- Logs go to file + console simultaneously (see `main.py` logging setup)
- All signal decisions are logged with timestamps and decision criteria
- Signal history stored in JSON (`signal_history.json`) for audit trail

### 4. Decision Records in Comments
- Complex logic includes **"Why we chose this"** in comments (Korean for clarity)
- Examples: Why Kalman variance = 1e-4? Why HMM has 3 states? Document the rationale

### 5. Config-Driven Design
- Email settings in `signal_mailer/config.yaml` (generated by `create_config.py`)
- Strategy parameters in code docstrings (e.g., MA20 threshold in percentiles)
- No hardcoding of credentials; use environment variables or config files

---

## Common Development Workflows

### Running Tests & Validation
```bash
# Pre-flight check for crash detection system (8 validation tests)
cd crash_detection_system
python tests/test_validation.py

# Tests verify: DataFetcher, data integrity, Kalman math, HMM regimes, 
# technical indicators, signal logic, NaN edge cases, cache idempotency
```

### Local Backtesting
```bash
# Run full pipeline: fetch data → detect signals → backtest → visualize
cd crash_detection_system
python src/main.py
# Output: results/backtest_report.json + graphs in logs/
```

### Testing Signal Mailer Locally
```bash
cd signal_mailer
python main.py --test-signal    # Simulate danger detection
python main.py --test-email     # Test SMTP send (doesn't send real email)
python main.py                  # Start scheduler (Ctrl+C to stop)
```

### GitHub Actions Deployment
- Secrets set in repo settings: `SENDER_EMAIL`, `SENDER_PASSWORD`, `RECIPIENT_EMAIL`, `GEMINI_API_KEY`
- Uses `auto_deploy.bat/sh` scripts to create repo and enable Actions
- Runs daily at UTC 0:00 (9 AM KST) via APScheduler + CronTrigger

---

## Key Technical Details

### Crash Detection Strategy (src/strategy.py)
- **Condition A**: RSI momentum reversal detected (breadth indicator)
- **Condition B**: HMM in "Crisis" regime (3-state model: Bull/Correction/Crisis)
- **Condition C**: VIX spike detected (volatility term structure)
- **Signal Rule**: SELL if (A AND C) OR (B); STRONG_BUY only for clear bull signals
- **Design Philosophy**: Precision > Recall (minimize false positives, accept missed signals)

### Signal Mailer Detection (signal_mailer/signal_detector.py)
- Calculates 20-day MA and volatility of SPY log-returns
- Danger triggered if: MA < 25th percentile OR volatility > 75th percentile (calculated from entire history)
- Stores signal state in JSON to prevent duplicate emails (state change only)
- Supports SPY, QQQ, XLP, SCHD, KOSPI200, GLD for portfolio rebalancing logic

### Regime Detection (GaussianHMM)
- 3 hidden states trained on SPY returns + VIX + breadth data
- States approximate: Bull (low volatility), Correction (medium), Crisis (high volatility)
- Used in `signal_processor.py` to context-weight other signals

---

## Dependencies & Environment
- **Core**: pandas, numpy, yfinance (market data)
- **ML/Signal**: scikit-learn (HMM), pykalman (Kalman Filter)
- **Automation**: apscheduler (scheduling), pyyaml (config parsing)
- **Email**: smtplib (built-in; supports Gmail app passwords via SMTP)
- **Optional**: vectorbt (backtesting; has fallback if unavailable)
- **AI**: google-generativeai (Gemini API for future signal synthesis)

**Requirements file**: `requirements.txt` (root) and `crash_detection_system/requirements.txt`

---

## Code Style & Naming
- **Korean comments** for decision rationale; **English** for code (variables, functions, docstrings)
- **Follow sklearn/pandas conventions**: `fit()`, `transform()`, `predict()`
- **Use type hints** in function signatures (Optional, Dict, Tuple, etc.)
- **Logging over print()** for all user-facing messages
- **Enum for signal types** (not magic integers): `SignalType.STRONG_SELL` not `-2`

---

## Before Submitting Work
1. ✅ Run validation: `python tests/test_validation.py` (crash detection) or `--test-signal/email` (mailer)
2. ✅ Check idempotency: Can you run twice without breaking?
3. ✅ Verify logs: Are decisions recorded with timestamps and criteria?
4. ✅ Test edge cases: Empty data? NaN values? First-run cache miss?
5. ✅ Document "Why": Add comment explaining non-obvious logic choices
