# 프로젝트 규칙

## Gemini Added Memories

### 커뮤니케이션 및 기록
- 사용자와의 대화 및 설명은 한국어로 진행합니다.
- 코드 내 변수명, 함수명, 주석은 **영어(English)**로 작성하여 글로벌 표준과 영어 학습 효과를 확보합니다.
- 결과물 제출 시 단순 완료 통보가 아닌 **\"요구사항 대비 충족 여부 검증 체크리스트\"**를 함께 요약하여 보고합니다.
- 복잡한 로직이나 알고리즘 선택 이유에는 주석으로 **'왜 이 방식을 선택했는지(Decision Record)'**를 한국어로 간략히 명시합니다.

### 인증 및 보안
- Gemini API를 사용하여 AI 기능을 구현합니다.
- 앱 비밀번호는 웹 브라우저가 아닌 환경에서 Google 계정에 접근할 때 사용하는 1회성 16자리 비밀번호입니다.
- 패스키 및 보안키와는 다른 개념입니다.
- 이메일 발송 기능을 위해 앱 비밀번호를 사용해야 합니다.

### 주의사항
- API 키와 앱 비밀번호는 `.env` 파일에 저장하고 버전 관리에서 제외합니다.
- 민감한 정보는 절대 코드에 하드코딩하지 않습니다.

## 개발 및 자동화 규칙 (Engineering & Quant Style)

### 자동화 원칙
- 작업의 자동화를 최대한으로 진행합니다.
- 반복 작업은 Python 기반 스크립트로 처리하며, **멱등성(Idempotency)**을 확보합니다.
- 멱등성 확보: 파일 중복 생성 방지, 이미 처리된 데이터 마킹, 여러 번 실행해도 결과가 동일하도록 설계합니다.
- 수동 작업을 최소화하고 효율성을 극대화합니다.

### Fail-Safe 설계
- 스크립트 실행 중 에러 발생 시 **Checkpoint(체크포인트)** 기능을 통해 진행 상태를 저장합니다.
- 필요시 **Rollback(롤백)** 로직으로 안전하게 초기 상태로 복구 가능하도록 구현합니다.
- 중단 시 데이터 유실을 방지하고 재실행 시 이어서 진행할 수 있도록 합니다.

### 작업 완료 프로세스
- 모든 작업 완료 후 **실행 → 테스트 → 검증** 단계를 필수로 진행합니다.
- 자동화된 테스트를 작성하여 회귀 버그를 방지합니다.
- **경계값 분석(Boundary Value Analysis)**을 통해 극단적인 상황에서의 오류를 사전에 방지합니다.
- 각 단계별 결과를 구조화된 로그(JSON/CSV)로 남깁니다.

### 데이터 처리 및 검증 (Strict Mode)
- 제공된 데이터는 임의로 요약하거나 중략하지 않고 **전체를 분석(Full Context)**합니다.
- 분량이 많을 경우 **분할 처리(Chunking) → 재조합(Reassembly)** 과정을 거쳐 전체 맥락을 유지합니다.
- 데이터의 타임스탬프, 단위, 출처가 명시되지 않은 경우 불완전 데이터로 간주하고 사용자에게 재확인을 요청합니다.
- **통계적 유의성**: 매매 횟수가 최소 10회 미만인 경우 신뢰도가 낮은 것으로 간주하고 주의 문구를 추가합니다.

### 5. 프로젝트 표준 포트폴리오 (Fixed Allocation)
모든 시스템 운영 및 백테스트는 아래의 고정 비중을 기본값으로 사용합니다.
- **SCHD (Dividend Growth)**: 38%
- **Tactical (QQQ/JEPI)**: 38% (정상 시 QQQ, 위험 시 JEPI 전환)
- **KOSPI (KS200)**: 19%
- **GLD (Gold)**: 5%
- 입력 데이터의 타입, 결측치, 이상치(Outlier)를 사전에 검사하고 문제 발생 시 즉시 리포트합니다.
- 테스트 데이터와 실제 데이터를 구분하여 관리합니다.
- 모든 검증 결과와 처리 과정을 구조화된 로그로 기록하여 추후 분석 및 감사가 가능하게 합니다.

## AI 에이전트 협업 규칙

### 에이전트 간 상호 교차 검증
- 서로 다른 AI 에이전트 간에 상호 피드백을 통해 작업을 진행합니다.
- **Red Team 방식**: A 에이전트가 작성한 코드를 B 에이전트(혹은 별도 세션)가 검수하여 논리적 허점을 찾습니다.
- 각 에이전트의 결과물을 독립적으로 검토하고 구체적인 개선점을 제시합니다.
- 피드백은 라인 번호 지목 등 **구체적이고 실행 가능**해야 합니다.

### 협업 프로세스
- 작업 분담: 에이전트별 역할과 책임을 명확히 정의합니다.
- 작업 분해: 요청사항은 **Input(데이터) → Process(로직) → Output(기대 결과)** 형태로 명확히 구조화합니다.
- 검증: 다른 에이전트가 결과를 독립적으로 검증합니다.
- 피드백 루프: 결과물이 의도와 다를 경우, 수정 사항을 Line Number 등으로 구체적으로 지목하여 반영 여부를 재확인합니다.
- 최종 승인: 모든 에이전트의 동의 하에 작업을 완료합니다.

### 코드 리뷰 기준
- 코드 스타일 일관성 확인 (변수명, 함수명 영어 사용)
- 보안 및 성능 최적화 검토 (특히 금융/퀀트 관련 로직의 정확성)
- 문서화 및 주석 충분성 점검 (Decision Record 포함)
- 멱등성과 Fail-Safe 구현 확인
- 테스트 커버리지 및 경계값 분석 확인

## 요청사항 처리 및 작업 지시 체계화

### 대화를 통한 요청사항 분석
- 사용자의 요청을 명확하게 이해하기 위해 충분한 질문과 대화를 진행합니다.
- 모호한 내용은 명확히 하고, 예시를 통해 의도를 확인합니다.
- 요청사항의 배경, 목적, 제약 조건을 파악합니다.

### 작업 지시사항 체계화
- 요청사항을 **구체적이고 실행 가능한 작업 단위**로 분해합니다.
- 각 작업의 **입력(Input), 처리(Process), 출력(Output)**을 명확히 정의합니다.
- 작업 간의 **선행 관계와 의존성**을 파악하고 구조화합니다.
- 성공 기준과 검증 방법을 명시합니다.

### 작업 계획 수립
- 우선순위를 정하여 작업 순서를 결정합니다.
- 예상 소요 시간과 리소스를 계획합니다.
- 위험 요소와 대응 방안을 사전에 준비합니다.

### Pre-Flight Check 절차 (제출 전 자가 검증)
- 모든 결과물 제출 전, AI는 반드시 내부적으로 **'요구사항 대조표'**를 작성하여 누락된 항목이 있는지 확인합니다.
- 코드는 문법 오류(Syntax Error)뿐만 아니라 **런타임 에러 가능성(Edge Case)**을 사전에 시뮬레이션해서 제출합니다.
- 3D 프린터의 베드 레벨링처럼, 모든 요소가 정렬되었음을 확인한 후 제출합니다.
- 결과 보고 형식: *\"작성 완료했습니다\"* 대신 *\"요구사항 A, B, C에 대해 검증을 마쳤으며, 결과물은 다음과 같습니다\"* 방식으로 구체적으로 보고합니다.

### 진행 상황 추적
- 작업 목록(Todo List)을 작성하여 진행 상황을 관리합니다.
- 완료, 진행 중, 미완료 상태를 명확히 구분합니다.
- 주기적으로 사용자와 진행 상황을 공유합니다.
